---
title: "Pteronura brasiliensis Model Run"
format: 
  html:
    toc: true
    toc-location: right
    smooth-scroll: true
    html-math-method: katex
    code-fold: true
self-contained: true
editor: source
author: 'Florencia Grattarola'
date: "`r format(Sys.time(), '%Y-%m-%d')`"
---

Model run for *Pteronura brasiliensis* with the data prepared in the previous step (including species and covariates data).  

  - R Libraries

```{r}
#| label: libraries
#| message: false
#| warning: false
#| code-fold: false

library(sf)
library(R2jags) # interface to JAGS
library(tidyverse)
```

## Data

```{r}
#| label: load-data
#| message: false
#| warning: false
#| code-fold: false

# Presence-absence data
pbrasiliensis_expert_blob_time1 <- readRDS('data/pbrasiliensis_expert_blob_time1.rds')
pbrasiliensis_expert_blob_time2 <- readRDS('data/pbrasiliensis_expert_blob_time2.rds')

PA_time1 <- readRDS('data/data_pbrasiliensis_PA_time1.rds') %>%
  cbind(expert=pbrasiliensis_expert_blob_time1) %>%
  filter(!is.na(env.bio_3) &!is.na(env.bio_5) & !is.na(env.wetland) & !is.na(env.woodysavanna) & !is.na(expert)) # remove NA's
PA_time2 <- readRDS('data/data_pbrasiliensis_PA_time2.rds') %>%
  cbind(expert=pbrasiliensis_expert_blob_time2) %>% 
  filter(!is.na(env.bio_3) &!is.na(env.bio_5) & !is.na(env.wetland) & !is.na(env.woodysavanna) & !is.na(expert)) # remove NA's

# Presence-only data
pbrasiliensis_expert_gridcell <- readRDS('data/pbrasiliensis_expert_gridcell.rds')

PO_time1 <- readRDS('data/data_pbrasiliensis_PO_time1.rds') %>%
  cbind(expert=pbrasiliensis_expert_gridcell$dist_exprt) %>% 
  filter(!is.na(env.bio_3) &!is.na(env.bio_5) & !is.na(env.wetland) & !is.na(env.woodysavanna) & !is.na(acce) & !is.na(count) & !is.na(expert)) # remove NA's
PO_time2  <- readRDS('data/data_pbrasiliensis_PO_time2.rds')  %>%
  cbind(expert=pbrasiliensis_expert_gridcell$dist_exprt) %>% 
  filter(!is.na(env.bio_3) &!is.na(env.bio_5) & !is.na(env.wetland) & !is.na(env.woodysavanna) & !is.na(acce) & !is.na(count) & !is.na(expert)) # remove NA's

PA_time1_time2 <- rbind(PA_time1 %>% mutate(time=1), PA_time2 %>% mutate(time=2)) 
PO_time1_time2 <- rbind(PO_time1 %>% mutate(time=1), PO_time2 %>% mutate(time=2)) 
```

## Splines

  -   Set the **`k` parameter**: the number of basis functions.  
  -   Set the **model formula**.  
  -   Fit the **GAM model**.  

```{r}
#| label: gam-model
#| message: false
#| warning: false

k = 9

gam.formula <- formula(count ~ env.bio_3 + 
                               env.bio_5 + 
                               env.wetland + 
                               env.woodysavanna +
                               expert +
                               offset(log(area)) +
                               s(X, Y, by=as.factor(time), k=k))

model.gam <- mgcv::gam(gam.formula, 
                       data = PO_time1_time2,
                       family = poisson)

summary(model.gam)
```                               

  -   Get the **jagam splines** values: using `mgcv::jagam`.  
  
```{r}
#| label: jagam-splines
#| message: false
#| warning: false

jagam.out <- mgcv::jagam(gam.formula, 
                         data = PO_time1_time2,
                         family = poisson,
                         file='') # we will not need this file

smooth1 <- jagam.out$pregam$smooth[[1]]
smooth2 <- jagam.out$pregam$smooth[[2]]

# presence-only data
jagam.PO.time1 <- mgcv::PredictMat(object = smooth1, data = PO_time1_time2)
jagam.PO.time2 <- mgcv::PredictMat(object = smooth2, data = PO_time1_time2)

# presence-absence data
jagam.PA.time1 <- mgcv::PredictMat(object = smooth1, data = PA_time1_time2)
jagam.PA.time2 <- mgcv::PredictMat(object = smooth2, data = PA_time1_time2)
```

## Prepare data for JAGS

```{r}
#| label: data-for-jags
#| message: false
#| warning: false

PA.X <- cbind('(Intercept)'= 1, 
              'env.bio_3' = PA_time1_time2$env.bio_3,
              'env.bio_5' = PA_time1_time2$env.bio_5,
              'env.wetland' = PA_time1_time2$env.wetland,
              'env.woodysavanna' = PA_time1_time2$env.woodysavanna,
              'expert' = PA_time1_time2$expert,
              jagam.PA.time1, 
              jagam.PA.time2)

PO.X <- cbind('(Intercept)'= 1, 
              'env.bio_3' = PO_time1_time2$env.bio_3,
              'env.bio_5' = PO_time1_time2$env.bio_5,
              'env.wetland' = PO_time1_time2$env.wetland,
              'env.woodysavanna' = PO_time1_time2$env.woodysavanna,
              'expert' = PO_time1_time2$expert,
              jagam.PO.time1, 
              jagam.PO.time2)

# number of all columns in X
n.X = ncol(PA.X)

# number of columns in X of spline basis functions
n.spl = ncol(jagam.PA.time1)

# number of columns in X of env. predictors + intercept
n.par = n.X - ncol(jagam.PA.time1)*2

# number of factors of time in X 
n.fac = length(unique(as.factor(PO_time1_time2$time)))*2

# country as an indexed variable
PO.country  <- as.numeric(as.factor(PO_time1_time2$country))

#number of countries
n.country <- length(unique(PO.country))

#global effort time1/time2 (see Range_map_offset.qmd)
global.effort <- rep(0.2715625, nrow(PO_time1_time2))

# for AUC
thr <- seq(0, 1, 0.05)

jags.data <- list(n.PA = nrow(PA_time1_time2),
                  y.PA = PA_time1_time2$presabs, 
                  X.PA = PA.X,
                  area.PA = PA_time1_time2$area,
                  effort = PA_time1_time2$effort,
                  n.PO = nrow(PO_time1_time2),
                  n.PO.half = nrow(PO_time1_time2)/2,
                  y.PO = PO_time1_time2$count, 
                  X.PO = PO.X,
                  area.PO = PO_time1_time2$area, 
                  acce = PO_time1_time2$acce,
                  country = PO.country,
                  global.effort = global.effort,
                  n.X = n.X,
                  n.cntr = n.country,
                  n.par = n.par,
                  n.fac = n.fac,
                  n.spl = n.spl,
                  Z = rep(0, length(jagam.out$jags.data$zero)),
                  S.time1 = jagam.out$jags.data$S1,
                  S.time2 = jagam.out$jags.data$S2, 
                  thr = thr)  

#jags.data
```

## Specify the model in BUGS language

```{r}
#| label: BUGS-model
#| message: false
#| warning: false

cat('model
  { 
    # PRIORS --------------------------------------------------
    
    ## Thinning at locations with complete accessibility in PO data
      
      # intercept of the decay function for each country of origin. 
      # It needs a flat prior between 0 and 1
      for (c in 1:n.cntr) 
      {
        alpha0[c] ~ dbeta(1, 1)  
      }

      # steepness of the decaying distance-P.ret relationship in PO data
      alpha1 ~ dgamma(0.5, 0.05)   
      
    ## Effect of sampling effort in PA data
      beta ~ dnorm(0, 0.01)
  
    ## Parametric effects of environment driving the point process intensity
     # (it also includes an intercept)
     
      for (r in 1:n.par)
      { 
        b[r] ~ dnorm(0,0.01) 
      }
      
    ## Splines (imported and adjusted form output of mgcv::jagam)
    
      ## prior for s(X,Y):as.factor(time)1 
      sigma.time1 <- S.time1[1:n.spl, 1:n.spl] * gamma[1]  + 
                     S.time1[1:n.spl, (n.spl + 1):(n.spl * 2)] * gamma[2]
      b[(n.par+1):(n.spl + n.par)] ~ dmnorm(Z[(n.par+1):(n.spl + n.par)], sigma.time1) 
     
      ## prior for s(X,Y):as.factor(time)2
      sigma.time2 <- S.time2[1:n.spl, 1:n.spl] * gamma[3]  + 
                     S.time2[1:n.spl, (n.spl + 1):(n.spl * 2)] * gamma[4]
      b[(n.X - n.spl + 1):(n.X)] ~ dmnorm(Z[(n.X - n.spl + 1):(n.X)], sigma.time2) 
     
      ## Priors for smoothing parameter 
      for (f in 1:n.fac) 
      {
        gamma[f] ~ dgamma(.5,.5)
        rho[f] <- log(gamma[f])
      }

    # LIKELIHOOD --------------------------------------------------
    
      ## --- Presence-Absence (PA) data ---
      
       eta.PA <- X.PA %*% b ## linear predictor
         
        
       for (i in 1:n.PA) 
       { 
         # the probability of presence
         cloglog(psi[i]) <- eta.PA[i] + log(area.PA[i]) + beta*log(effort[i])
        
         # presences and absences come from a Bernoulli distribution
         y.PA[i] ~ dbern(psi[i]*0.9999) 
       }
  
      ## --- Presence-Only (PO) data --- 
  
      eta.PO <- X.PO %*% b  ## linear predictor

      for (j in 1:n.PO)
      {
        # cell-specific probability of retainin (observing) a point is a function of accessibility
        P.ret[j] <- alpha0[country[j]] * exp( (-alpha1) * acce[j]) 
        
        # true mean number (nu) of points per cell i is the true intensity multiplied by cell area
        log(nu[j]) <- eta.PO[j] + log(area.PO[j])

        # thinning: the true lambda
        lambda[j] <- ifelse(j > n.PO.half,
                                nu[j] * P.ret[j],                    #time1
                                nu[j] * P.ret[j] * global.effort[j]) #time2

        # counts of observed points come from a Poisson distribution
        y.PO[j] ~ dpois(lambda[j]) 
      }
  
    # PREDICTIONS -------------------------------------------------

    eta.pred <- X.PO %*% b

    for (j in 1:n.PO)
    {
      # predicted probability of occurrence in grid cell j
      cloglog(P.pred[j]) <- eta.pred[j] + log(area.PO[j])
    }

    # POSTERIOR PREDICTIVE CHECK  --------------------------------
    
    # for PA
    for (i in 1:n.PA)
    {
      # Fit assessments: Tjur R-Squared (fit statistic for logistic regression)
      pres[i] <- ifelse(y.PA[i] > 0, psi[i], 0)
      absc[i] <- ifelse(y.PA[i] == 0, psi[i], 0)
    }
    
    # Discrepancy measures for entire PA data set
    pres.n <- sum(y.PA[] > 0)
    absc.n <- sum(y.PA[] == 0)
    r2_tjur <- abs(sum(pres[])/pres.n - sum(absc[])/absc.n)

    # for PO
    for (j in 1:n.PO)
    {
      # Fit assessments: Posterior predictive check and data for DHARMA
      y.PO.new[j] ~ dpois(lambda[j]) 

    }
    
    # AUC
    for (t in 1:length(thr)) {
        sens[t] <- sum((psi > thr[t]) && (y.PA==1))/pres.n   #tpr (sensitivity)
        spec[t] <- sum((psi < thr[t]) && (y.PA==0))/absc.n   
        fpr[t] <- 1 - spec[t]                                #fpr (1-specificity)
    }
    auc <- sum((sens[2:length(sens)]+sens[1:(length(sens)-1)])/2 * 
    -(fpr[2:length(fpr)] - fpr[1:(length(fpr)-1)]))

    # DERIVED QUANTITIES ------------------------------------------
    
    # area in each time period, and temporal change of area
    A.time1 <- sum(P.pred[1:n.PO.half])
    A.time2 <- sum(P.pred[(n.PO.half+1):n.PO])
    delta.A <- A.time2 - A.time1
    
    # uncertainty for the temporal change
    for (j in 1:n.PO.half)
    {
      delta.Grid[j] <- P.pred[n.PO.half+j] - P.pred[j]
    }
  }
', file = 'models/pbrasiliensis_model.txt')
```


## Inits function

```{r}
#| label: inits
#| message: false
#| warning: false


jags.inits <- function(model = model.gam)
{
  return(list(b=rnorm(n.X, mean=model$coefficients, sd=1)))
}

```

## Fit the model

```{r}
#| label: run
#| message: false
#| warning: false
#| eval: true

start.time <- Sys.time()

pbrasiliensis_model <- R2jags::jags(data=jags.data,
                                model.file='models/pbrasiliensis_model.txt',
                                parameters.to.save=c('b', 'P.pred', 
                                            'A.time1', 'A.time2', 'delta.A',
                                            'alpha0', 'alpha1', 'beta',
                                            'lambda', 'P.ret', 'psi',
                                            'y.PO.new', 'r2_tjur', 
                                            'auc', 'sens', 'fpr',
                                            'delta.Grid'),
                                inits = jags.inits,
                                n.chains=3,
                                n.iter=100000,
                                n.thin=10,
                                n.burnin=10000,
                                DIC = FALSE)

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken

saveRDS(pbrasiliensis_model, 'big_data/pbrasiliensis_model.rds')
```
